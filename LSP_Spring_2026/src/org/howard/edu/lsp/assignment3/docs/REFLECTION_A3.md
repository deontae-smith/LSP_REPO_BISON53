# Assignment 3 Reflection: Object-Oriented Redesign

## Overview
Assignment 3 redesigns the original ETL program into a more object-oriented architecture while preserving the exact same behavior, inputs, outputs, transformations, and error handling as Assignment 2. In Assignment 2, the entire program logic was implemented inside a single class. Meaning validation, file reading and writing, data parsing, transformation logic, error handling, and summary reporting—were handled within one file. This made the program functional but harder to maintain and extend.In Assignment 3, the system was redesigned into multiple classes, each with a clearly defined responsibility. The ETLPipeline class controls the execution flow of the program, while CSVProcessor handles all file input and output operations. Product serves as the data model, and ProductTransformer contains the transformation business logic. Finally, ETLSummary tracks and prints processing statistics. This separation of concerns makes the program more modular, readable, maintainable, and scalable. Assignment 3 applies object-oriented principles by modeling real-world concepts as objects. Instead of treating each CSV row as loosely related variables, each row is represented as a Product object. This encapsulates related data (productId, name, price, category) into a single coherent unit. Responsibilities are given across classes rather than  in one large procedural structure. Each class has a focused role, which follows the Single Responsibility Principle. This improves clarity and reduces dependency between components. The design also makes it easier to extend the system. For example, adding new transformation rules would only require modifying the ProductTransformer class, without affecting file handling logic. Several object-oriented concepts were applied throughout the redesign. The system was structured using multiple classes, including Product, CSVProcessor, ProductTransformer, ETLSummary, and ETLPipeline, each serving a distinct purpose. Objects were then instantiated from these classes, with instances of Product representing individual products from the CSV file and an instance of ETLSummary tracking statistics during execution, both maintaining their own state and behavior. Encapsulation was a key principle, as each class hides its internal implementation details — for example, the Product class stores fields as private and exposes them through getters, ETLSummary controls how counters are incremented through public methods, and transformation logic is fully contained within ProductTransformer, ensuring data integrity and controlled access. Inheritance was not required in this redesign, as the problem did not involve hierarchical relationships and was better structured through composition. The design leaves room for future extension, such as introducing different transformer strategies. Overall, the most important object-oriented concepts applied were class design, object modeling, and encapsulation.

## Testing
To confirm that Assignment 3 behaves exactly like Assignment 2, a series of tests were performed using the same input file, data/products.csv, for both versions. The output file, data/transformed_products.csv, was then compared across both implementations to ensure the results were identical. This included verifying that Electronics products correctly receive a 10% discount, Premium Electronics are labeled properly, and price ranges — Low, Medium, High, and Premium — match exactly. Error handling was also validated, confirming that invalid rows, empty lines, incorrect field counts, and invalid numeric values are all skipped as expected. Finally, the summary statistics, including rows read, transformed, and skipped, were confirmed to match exactly between both versions. All outputs, error handling behavior, and console summaries were identical, confirming functional equivalence between the two implementations.